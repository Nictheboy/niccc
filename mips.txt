	.text
	.globl _start
	.globl main
_start:
	jal main
	nop
	move $a0, $v0
	li $v0, 17
	syscall
printf:
	addi $sp, $sp, -32
	sw $ra, 28($sp)
	sw $fp, 24($sp)
	sw $s0, 20($sp)
	sw $s1, 16($sp)
	sw $s2, 12($sp)
	sw $s3, 8($sp)
	sw $s4, 4($sp)
	move $fp, $sp
	move $s0, $a0
	move $s1, $a1
	move $s2, $a2
	move $s3, $a3
	li $s4, 0
printf_loop_start:
	lb $t0, 0($s0)
	beq $t0, $zero, printf_end
	nop
	li $t1, '%'
	bne $t0, $t1, printf_print_char_direct
	nop
	addi $s0, $s0, 1
	lb $t0, 0($s0)
	beq $t0, $zero, printf_end
	nop
	li $t1, 'd'
	bne $t0, $t1, printf_handle_literal_percent
	nop
	move $t1, $s1
	beq $s4, 1, printf_use_arg2
	nop
	beq $s4, 2, printf_use_arg3
	nop
	j printf_perform_print_int
	nop
printf_use_arg2:
	move $t1, $s2
	j printf_perform_print_int
	nop
printf_use_arg3:
	move $t1, $s3
printf_perform_print_int:
	move $a0, $t1
	li $v0, 1
	syscall
	addi $s4, $s4, 1
	j printf_loop_continue
	nop
printf_handle_literal_percent:
	li $t1, '%'
	bne $t0, $t1, printf_unknown_specifier
	nop
printf_print_char_direct:
	move $a0, $t0
	li $v0, 11
	syscall
	j printf_loop_continue
	nop
printf_unknown_specifier:
	li $a0, '%'
	li $v0, 11
	syscall
	move $a0, $t0
	li $v0, 11
	syscall
	j printf_loop_continue
	nop
printf_loop_continue:
	addi $s0, $s0, 1
	j printf_loop_start
	nop
printf_end:
	lw $s4, 4($sp)
	lw $s3, 8($sp)
	lw $s2, 12($sp)
	lw $s1, 16($sp)
	lw $s0, 20($sp)
	lw $fp, 24($sp)
	lw $ra, 28($sp)
	addi $sp, $sp, 32
	jr $ra
	nop
getint:
	addi $sp, $sp, -8
	sw $ra, 4($sp)
	sw $fp, 0($sp)
	move $fp, $sp
	li $v0, 5
	syscall
	lw $fp, 0($sp)
	lw $ra, 4($sp)
	addi $sp, $sp, 8
	jr $ra
	nop
	# Local var '%tmp_addsub_29' assigned stack offset: -4($fp)
	# Local var '%tmp_addsub_30' assigned stack offset: -8($fp)
	# Local var '%tmp_addsub_33' assigned stack offset: -12($fp)
	# Local var '%tmp_arr_load_32' assigned stack offset: -16($fp)
	# Local var '%tmp_call_getint_28' assigned stack offset: -20($fp)
	# Local var '%tmp_rel_27' assigned stack offset: -24($fp)
	# Local var '%tmp_rel_31' assigned stack offset: -28($fp)
	# Local var 'i' assigned stack offset: -32($fp)
	# Local var 'len' assigned stack offset: -36($fp)
	# Function main: totalLocalVarSize = -36, frameSize = 44
main:
	# Prologue for main
	addiu $sp, $sp, -44
	sw $ra, 40($sp)
	sw $fp, 36($sp)
	addiu $fp, $sp, 36
	# AssignInst: len = 10
	# Ensuring operand 10 is in a register
	# Reserved temporary register $t0
	li $t0, 10
	sw $t0, -36($fp)
	# Stored to local len at -36($fp)
	# Released temporary register $t0
	# AssignInst: i = 0
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	sw $t0, -32($fp)
	# Stored to local i at -32($fp)
	# Released temporary register $t0
.L_while_cond_18:
	# CallPureInst: CALL_PURE __builtin_lt_int(i:INTEGER, len:INTEGER) -> (%tmp_rel_27:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -32($fp)
	# Loaded local var i from -32($fp) into $t0
	# Ensuring operand len:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -36($fp)
	# Loaded local var len from -36($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t0, $t1
	sw $t2, -24($fp)
	# Stored result of pure call to local %tmp_rel_27 at -24($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_27:INTEGER) goto .L_while_body_19 else goto .L_while_end_20
	# Ensuring operand %tmp_rel_27:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -24($fp)
	# Loaded local var %tmp_rel_27 from -24($fp) into $t0
	bnez $t0, .L_while_body_19
	nop
	j .L_while_end_20
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_19:
	# --- Calling function: getint ---
	jal getint
	nop
	sw $v0, -20($fp)
	# Variable %tmp_call_getint_28 (result of getint) stored from $v0
	# --- End of call to getint ---
	# StoreArrayInst: STORE arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[i:INTEGER], %tmp_call_getint_28:INTEGER
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -32($fp)
	# Loaded local var i from -32($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Ensuring operand %tmp_call_getint_28:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -20($fp)
	# Loaded local var %tmp_call_getint_28 from -20($fp) into $t4
	# Value to store in 'arr[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'arr[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for arr ---
	# CallPureInst: CALL_PURE __builtin_add_int(i:INTEGER, 1) -> (%tmp_addsub_29:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -32($fp)
	# Loaded local var i from -32($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -4($fp)
	# Stored result of pure call to local %tmp_addsub_29 at -4($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: i = %tmp_addsub_29:INTEGER
	# Ensuring operand %tmp_addsub_29:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var %tmp_addsub_29 from -4($fp) into $t0
	sw $t0, -32($fp)
	# Stored to local i at -32($fp)
	# Released temporary register $t0
	j .L_while_cond_18
.L_while_end_20:
	# CallPureInst: CALL_PURE __builtin_sub_int(len:INTEGER, 1) -> (%tmp_addsub_30:INTEGER)
	# Ensuring operand len:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -36($fp)
	# Loaded local var len from -36($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	subu $t2, $t0, $t1
	sw $t2, -8($fp)
	# Stored result of pure call to local %tmp_addsub_30 at -8($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# --- Calling function: mergeSort ---
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	move $a0, $t0
	# Ensuring operand %tmp_addsub_30:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var %tmp_addsub_30 from -8($fp) into $t1
	move $a1, $t1
	jal mergeSort
	nop
	# Released temporary register $t0
	# Released temporary register $t1
	# --- End of call to mergeSort ---
	# AssignInst: i = 0
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	sw $t0, -32($fp)
	# Stored to local i at -32($fp)
	# Released temporary register $t0
.L_while_cond_21:
	# CallPureInst: CALL_PURE __builtin_lt_int(i:INTEGER, len:INTEGER) -> (%tmp_rel_31:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -32($fp)
	# Loaded local var i from -32($fp) into $t0
	# Ensuring operand len:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -36($fp)
	# Loaded local var len from -36($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t0, $t1
	sw $t2, -28($fp)
	# Stored result of pure call to local %tmp_rel_31 at -28($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_31:INTEGER) goto .L_while_body_22 else goto .L_while_end_23
	# Ensuring operand %tmp_rel_31:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -28($fp)
	# Loaded local var %tmp_rel_31 from -28($fp) into $t0
	bnez $t0, .L_while_body_22
	nop
	j .L_while_end_23
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_22:
	# LoadArrayInst: %tmp_arr_load_32:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[i:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -32($fp)
	# Loaded local var i from -32($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -16($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_32' at offset -16
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# --- Calling function: printf ---
	# Ensuring operand label _S0 is in a register
	# Reserved temporary register $t0
	la $t0, _S0
	# Loaded address of label _S0 into $t0
	move $a0, $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -32($fp)
	# Loaded local var i from -32($fp) into $t1
	move $a1, $t1
	# Ensuring operand %tmp_arr_load_32:INTEGER is in a register
	# Reserved temporary register $t2
	lw $t2, -16($fp)
	# Loaded local var %tmp_arr_load_32 from -16($fp) into $t2
	move $a2, $t2
	jal printf
	nop
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# --- End of call to printf ---
	# CallPureInst: CALL_PURE __builtin_add_int(i:INTEGER, 1) -> (%tmp_addsub_33:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -32($fp)
	# Loaded local var i from -32($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -12($fp)
	# Stored result of pure call to local %tmp_addsub_33 at -12($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: i = %tmp_addsub_33:INTEGER
	# Ensuring operand %tmp_addsub_33:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -12($fp)
	# Loaded local var %tmp_addsub_33 from -12($fp) into $t0
	sw $t0, -32($fp)
	# Stored to local i at -32($fp)
	# Released temporary register $t0
	j .L_while_cond_21
.L_while_end_23:
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	move $v0, $t0
	j main_epilogue
	nop
main_epilogue:
	# Epilogue for main
	lw $ra, 4($fp)
	lw $fp, 0($fp)
	addiu $sp, $sp, 44
	jr $ra
	nop
	# Parameter 'start' assigned stack offset: -4($fp)
	# Parameter 'mid' assigned stack offset: -8($fp)
	# Parameter 'end' assigned stack offset: -12($fp)
	# Local var '%tmp_addsub_0' assigned stack offset: -16($fp)
	# Local var '%tmp_addsub_10' assigned stack offset: -20($fp)
	# Local var '%tmp_addsub_13' assigned stack offset: -24($fp)
	# Local var '%tmp_addsub_14' assigned stack offset: -28($fp)
	# Local var '%tmp_addsub_17' assigned stack offset: -32($fp)
	# Local var '%tmp_addsub_18' assigned stack offset: -36($fp)
	# Local var '%tmp_addsub_20' assigned stack offset: -40($fp)
	# Local var '%tmp_addsub_22' assigned stack offset: -44($fp)
	# Local var '%tmp_addsub_6' assigned stack offset: -48($fp)
	# Local var '%tmp_addsub_7' assigned stack offset: -52($fp)
	# Local var '%tmp_addsub_9' assigned stack offset: -56($fp)
	# Local var '%tmp_arr_load_12' assigned stack offset: -60($fp)
	# Local var '%tmp_arr_load_16' assigned stack offset: -64($fp)
	# Local var '%tmp_arr_load_2' assigned stack offset: -68($fp)
	# Local var '%tmp_arr_load_21' assigned stack offset: -72($fp)
	# Local var '%tmp_arr_load_3' assigned stack offset: -76($fp)
	# Local var '%tmp_arr_load_5' assigned stack offset: -80($fp)
	# Local var '%tmp_arr_load_8' assigned stack offset: -84($fp)
	# Local var '%tmp_rel_1' assigned stack offset: -88($fp)
	# Local var '%tmp_rel_11' assigned stack offset: -92($fp)
	# Local var '%tmp_rel_15' assigned stack offset: -96($fp)
	# Local var '%tmp_rel_19' assigned stack offset: -100($fp)
	# Local var '%tmp_rel_4' assigned stack offset: -104($fp)
	# Local var 'i' assigned stack offset: -108($fp)
	# Local var 'j' assigned stack offset: -112($fp)
	# Local var 'k' assigned stack offset: -116($fp)
	# Local var 'm' assigned stack offset: -120($fp)
	# Function merge: totalLocalVarSize = -120, frameSize = 128
merge:
	# Prologue for merge
	addiu $sp, $sp, -128
	sw $ra, 124($sp)
	sw $fp, 120($sp)
	addiu $fp, $sp, 120
	sw $a0, -4($fp)
	# Stored $a0 (param 'start') to -4($fp)
	sw $a1, -8($fp)
	# Stored $a1 (param 'mid') to -8($fp)
	sw $a2, -12($fp)
	# Stored $a2 (param 'end') to -12($fp)
	# AssignInst: k = 0
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	sw $t0, -116($fp)
	# Stored to local k at -116($fp)
	# Released temporary register $t0
	# AssignInst: i = start:INTEGER
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	sw $t0, -108($fp)
	# Stored to local i at -108($fp)
	# Released temporary register $t0
	# CallPureInst: CALL_PURE __builtin_add_int(mid:INTEGER, 1) -> (%tmp_addsub_0:INTEGER)
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -8($fp)
	# Loaded local var mid from -8($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -16($fp)
	# Stored result of pure call to local %tmp_addsub_0 at -16($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: j = %tmp_addsub_0:INTEGER
	# Ensuring operand %tmp_addsub_0:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -16($fp)
	# Loaded local var %tmp_addsub_0 from -16($fp) into $t0
	sw $t0, -112($fp)
	# Stored to local j at -112($fp)
	# Released temporary register $t0
.L_while_cond_0:
	# CallPureInst: CALL_PURE __builtin_le_int(i:INTEGER, mid:INTEGER) -> (%tmp_rel_1:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -108($fp)
	# Loaded local var i from -108($fp) into $t0
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var mid from -8($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t1, $t0
	xori $t2, $t2, 1
	sw $t2, -88($fp)
	# Stored result of pure call to local %tmp_rel_1 at -88($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_1:INTEGER) goto .L_while_body_1 else goto .L_while_end_2
	# Ensuring operand %tmp_rel_1:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -88($fp)
	# Loaded local var %tmp_rel_1 from -88($fp) into $t0
	bnez $t0, .L_while_body_1
	nop
	j .L_while_end_2
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_1:
	# LoadArrayInst: %tmp_arr_load_2:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[i:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -108($fp)
	# Loaded local var i from -108($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -68($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_2' at offset -68
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# LoadArrayInst: %tmp_arr_load_3:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[j:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -112($fp)
	# Loaded local var j from -112($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -76($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_3' at offset -76
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# CallPureInst: CALL_PURE __builtin_lt_int(%tmp_arr_load_2:INTEGER, %tmp_arr_load_3:INTEGER) -> (%tmp_rel_4:INTEGER)
	# Ensuring operand %tmp_arr_load_2:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -68($fp)
	# Loaded local var %tmp_arr_load_2 from -68($fp) into $t0
	# Ensuring operand %tmp_arr_load_3:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -76($fp)
	# Loaded local var %tmp_arr_load_3 from -76($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t0, $t1
	sw $t2, -104($fp)
	# Stored result of pure call to local %tmp_rel_4 at -104($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_4:INTEGER) goto .L_if_then_3 else goto .L_if_else_4
	# Ensuring operand %tmp_rel_4:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -104($fp)
	# Loaded local var %tmp_rel_4 from -104($fp) into $t0
	bnez $t0, .L_if_then_3
	nop
	j .L_if_else_4
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_if_then_3:
	# LoadArrayInst: %tmp_arr_load_5:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[i:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -108($fp)
	# Loaded local var i from -108($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -80($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_5' at offset -80
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# StoreArrayInst: STORE result:ARRAY(dims=1, sizes=[20], type=INTEGER)[k:INTEGER], %tmp_arr_load_5:INTEGER
	# Reserved temporary register $t0
	la $t0, result
	# Loaded base address of global array 'result' into $t0
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -116($fp)
	# Loaded local var k from -116($fp) into $t1
	# Index value for 'result' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'result[index]' into $t0
	# Ensuring operand %tmp_arr_load_5:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -80($fp)
	# Loaded local var %tmp_arr_load_5 from -80($fp) into $t4
	# Value to store in 'result[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'result[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for result ---
	# CallPureInst: CALL_PURE __builtin_add_int(k:INTEGER, 1) -> (%tmp_addsub_6:INTEGER)
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -116($fp)
	# Loaded local var k from -116($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -48($fp)
	# Stored result of pure call to local %tmp_addsub_6 at -48($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: k = %tmp_addsub_6:INTEGER
	# Ensuring operand %tmp_addsub_6:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -48($fp)
	# Loaded local var %tmp_addsub_6 from -48($fp) into $t0
	sw $t0, -116($fp)
	# Stored to local k at -116($fp)
	# Released temporary register $t0
	# CallPureInst: CALL_PURE __builtin_add_int(i:INTEGER, 1) -> (%tmp_addsub_7:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -108($fp)
	# Loaded local var i from -108($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -52($fp)
	# Stored result of pure call to local %tmp_addsub_7 at -52($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: i = %tmp_addsub_7:INTEGER
	# Ensuring operand %tmp_addsub_7:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -52($fp)
	# Loaded local var %tmp_addsub_7 from -52($fp) into $t0
	sw $t0, -108($fp)
	# Stored to local i at -108($fp)
	# Released temporary register $t0
	j .L_if_endif_5
.L_if_else_4:
	# LoadArrayInst: %tmp_arr_load_8:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[j:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -112($fp)
	# Loaded local var j from -112($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -84($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_8' at offset -84
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# StoreArrayInst: STORE result:ARRAY(dims=1, sizes=[20], type=INTEGER)[k:INTEGER], %tmp_arr_load_8:INTEGER
	# Reserved temporary register $t0
	la $t0, result
	# Loaded base address of global array 'result' into $t0
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -116($fp)
	# Loaded local var k from -116($fp) into $t1
	# Index value for 'result' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'result[index]' into $t0
	# Ensuring operand %tmp_arr_load_8:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -84($fp)
	# Loaded local var %tmp_arr_load_8 from -84($fp) into $t4
	# Value to store in 'result[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'result[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for result ---
	# CallPureInst: CALL_PURE __builtin_add_int(k:INTEGER, 1) -> (%tmp_addsub_9:INTEGER)
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -116($fp)
	# Loaded local var k from -116($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -56($fp)
	# Stored result of pure call to local %tmp_addsub_9 at -56($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: k = %tmp_addsub_9:INTEGER
	# Ensuring operand %tmp_addsub_9:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -56($fp)
	# Loaded local var %tmp_addsub_9 from -56($fp) into $t0
	sw $t0, -116($fp)
	# Stored to local k at -116($fp)
	# Released temporary register $t0
	# CallPureInst: CALL_PURE __builtin_add_int(j:INTEGER, 1) -> (%tmp_addsub_10:INTEGER)
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -112($fp)
	# Loaded local var j from -112($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -20($fp)
	# Stored result of pure call to local %tmp_addsub_10 at -20($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: j = %tmp_addsub_10:INTEGER
	# Ensuring operand %tmp_addsub_10:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -20($fp)
	# Loaded local var %tmp_addsub_10 from -20($fp) into $t0
	sw $t0, -112($fp)
	# Stored to local j at -112($fp)
	# Released temporary register $t0
.L_if_endif_5:
	j .L_while_cond_0
.L_while_end_2:
.L_while_cond_6:
	# CallPureInst: CALL_PURE __builtin_le_int(i:INTEGER, mid:INTEGER) -> (%tmp_rel_11:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -108($fp)
	# Loaded local var i from -108($fp) into $t0
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var mid from -8($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t1, $t0
	xori $t2, $t2, 1
	sw $t2, -92($fp)
	# Stored result of pure call to local %tmp_rel_11 at -92($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_11:INTEGER) goto .L_while_body_7 else goto .L_while_end_8
	# Ensuring operand %tmp_rel_11:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -92($fp)
	# Loaded local var %tmp_rel_11 from -92($fp) into $t0
	bnez $t0, .L_while_body_7
	nop
	j .L_while_end_8
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_7:
	# LoadArrayInst: %tmp_arr_load_12:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[i:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -108($fp)
	# Loaded local var i from -108($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -60($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_12' at offset -60
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# StoreArrayInst: STORE result:ARRAY(dims=1, sizes=[20], type=INTEGER)[k:INTEGER], %tmp_arr_load_12:INTEGER
	# Reserved temporary register $t0
	la $t0, result
	# Loaded base address of global array 'result' into $t0
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -116($fp)
	# Loaded local var k from -116($fp) into $t1
	# Index value for 'result' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'result[index]' into $t0
	# Ensuring operand %tmp_arr_load_12:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -60($fp)
	# Loaded local var %tmp_arr_load_12 from -60($fp) into $t4
	# Value to store in 'result[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'result[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for result ---
	# CallPureInst: CALL_PURE __builtin_add_int(k:INTEGER, 1) -> (%tmp_addsub_13:INTEGER)
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -116($fp)
	# Loaded local var k from -116($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -24($fp)
	# Stored result of pure call to local %tmp_addsub_13 at -24($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: k = %tmp_addsub_13:INTEGER
	# Ensuring operand %tmp_addsub_13:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -24($fp)
	# Loaded local var %tmp_addsub_13 from -24($fp) into $t0
	sw $t0, -116($fp)
	# Stored to local k at -116($fp)
	# Released temporary register $t0
	# CallPureInst: CALL_PURE __builtin_add_int(i:INTEGER, 1) -> (%tmp_addsub_14:INTEGER)
	# Ensuring operand i:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -108($fp)
	# Loaded local var i from -108($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -28($fp)
	# Stored result of pure call to local %tmp_addsub_14 at -28($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: i = %tmp_addsub_14:INTEGER
	# Ensuring operand %tmp_addsub_14:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -28($fp)
	# Loaded local var %tmp_addsub_14 from -28($fp) into $t0
	sw $t0, -108($fp)
	# Stored to local i at -108($fp)
	# Released temporary register $t0
	j .L_while_cond_6
.L_while_end_8:
.L_while_cond_9:
	# CallPureInst: CALL_PURE __builtin_le_int(j:INTEGER, end:INTEGER) -> (%tmp_rel_15:INTEGER)
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -112($fp)
	# Loaded local var j from -112($fp) into $t0
	# Ensuring operand end:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -12($fp)
	# Loaded local var end from -12($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t1, $t0
	xori $t2, $t2, 1
	sw $t2, -96($fp)
	# Stored result of pure call to local %tmp_rel_15 at -96($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_15:INTEGER) goto .L_while_body_10 else goto .L_while_end_11
	# Ensuring operand %tmp_rel_15:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -96($fp)
	# Loaded local var %tmp_rel_15 from -96($fp) into $t0
	bnez $t0, .L_while_body_10
	nop
	j .L_while_end_11
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_10:
	# LoadArrayInst: %tmp_arr_load_16:INTEGER = LOAD arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[j:INTEGER]
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -112($fp)
	# Loaded local var j from -112($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'arr[index]' into temp reg $t4
	sw $t4, -64($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_16' at offset -64
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for arr ---
	# StoreArrayInst: STORE result:ARRAY(dims=1, sizes=[20], type=INTEGER)[k:INTEGER], %tmp_arr_load_16:INTEGER
	# Reserved temporary register $t0
	la $t0, result
	# Loaded base address of global array 'result' into $t0
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -116($fp)
	# Loaded local var k from -116($fp) into $t1
	# Index value for 'result' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'result[index]' into $t0
	# Ensuring operand %tmp_arr_load_16:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -64($fp)
	# Loaded local var %tmp_arr_load_16 from -64($fp) into $t4
	# Value to store in 'result[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'result[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for result ---
	# CallPureInst: CALL_PURE __builtin_add_int(k:INTEGER, 1) -> (%tmp_addsub_17:INTEGER)
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -116($fp)
	# Loaded local var k from -116($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -32($fp)
	# Stored result of pure call to local %tmp_addsub_17 at -32($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: k = %tmp_addsub_17:INTEGER
	# Ensuring operand %tmp_addsub_17:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -32($fp)
	# Loaded local var %tmp_addsub_17 from -32($fp) into $t0
	sw $t0, -116($fp)
	# Stored to local k at -116($fp)
	# Released temporary register $t0
	# CallPureInst: CALL_PURE __builtin_add_int(j:INTEGER, 1) -> (%tmp_addsub_18:INTEGER)
	# Ensuring operand j:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -112($fp)
	# Loaded local var j from -112($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -36($fp)
	# Stored result of pure call to local %tmp_addsub_18 at -36($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: j = %tmp_addsub_18:INTEGER
	# Ensuring operand %tmp_addsub_18:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -36($fp)
	# Loaded local var %tmp_addsub_18 from -36($fp) into $t0
	sw $t0, -112($fp)
	# Stored to local j at -112($fp)
	# Released temporary register $t0
	j .L_while_cond_9
.L_while_end_11:
	# AssignInst: m = 0
	# Ensuring operand 0 is in a register
	# Reserved temporary register $t0
	li $t0, 0
	sw $t0, -120($fp)
	# Stored to local m at -120($fp)
	# Released temporary register $t0
.L_while_cond_12:
	# CallPureInst: CALL_PURE __builtin_lt_int(m:INTEGER, k:INTEGER) -> (%tmp_rel_19:INTEGER)
	# Ensuring operand m:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -120($fp)
	# Loaded local var m from -120($fp) into $t0
	# Ensuring operand k:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -116($fp)
	# Loaded local var k from -116($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t0, $t1
	sw $t2, -100($fp)
	# Stored result of pure call to local %tmp_rel_19 at -100($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_19:INTEGER) goto .L_while_body_13 else goto .L_while_end_14
	# Ensuring operand %tmp_rel_19:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -100($fp)
	# Loaded local var %tmp_rel_19 from -100($fp) into $t0
	bnez $t0, .L_while_body_13
	nop
	j .L_while_end_14
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_while_body_13:
	# CallPureInst: CALL_PURE __builtin_add_int(start:INTEGER, m:INTEGER) -> (%tmp_addsub_20:INTEGER)
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	# Ensuring operand m:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -120($fp)
	# Loaded local var m from -120($fp) into $t1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -40($fp)
	# Stored result of pure call to local %tmp_addsub_20 at -40($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# LoadArrayInst: %tmp_arr_load_21:INTEGER = LOAD result:ARRAY(dims=1, sizes=[20], type=INTEGER)[m:INTEGER]
	# Reserved temporary register $t0
	la $t0, result
	# Loaded base address of global array 'result' into $t0
	# Ensuring operand m:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -120($fp)
	# Loaded local var m from -120($fp) into $t1
	# Index value for 'result' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'result[index]' into $t0
	# Reserved temporary register $t4
	lw $t4, 0($t0)
	# Loaded value from 'result[index]' into temp reg $t4
	sw $t4, -72($fp)
	# Stored loaded array element to local destination '%tmp_arr_load_21' at offset -72
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of LoadArrayInst for result ---
	# StoreArrayInst: STORE arr:ARRAY(dims=1, sizes=[20], type=INTEGER)[%tmp_addsub_20:INTEGER], %tmp_arr_load_21:INTEGER
	# Reserved temporary register $t0
	la $t0, arr
	# Loaded base address of global array 'arr' into $t0
	# Ensuring operand %tmp_addsub_20:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -40($fp)
	# Loaded local var %tmp_addsub_20 from -40($fp) into $t1
	# Index value for 'arr' is in $t1
	# Reserved temporary register $t2
	li $t2, 4
	# Reserved temporary register $t3
	multu $t1, $t2
	mflo $t3
	# Calculated offset_in_bytes ($t1 * 4) into $t3
	addu $t0, $t0, $t3
	# Calculated final element address for 'arr[index]' into $t0
	# Ensuring operand %tmp_arr_load_21:INTEGER is in a register
	# Reserved temporary register $t4
	lw $t4, -72($fp)
	# Loaded local var %tmp_arr_load_21 from -72($fp) into $t4
	# Value to store in 'arr[index]' is in $t4
	sw $t4, 0($t0)
	# Stored value from $t4 into 'arr[index]'
	# Released temporary register $t4
	# Released temporary register $t3
	# Released temporary register $t2
	# Released temporary register $t1
	# Released temporary register $t0
	# --- End of StoreArrayInst for arr ---
	# CallPureInst: CALL_PURE __builtin_add_int(m:INTEGER, 1) -> (%tmp_addsub_22:INTEGER)
	# Ensuring operand m:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -120($fp)
	# Loaded local var m from -120($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -44($fp)
	# Stored result of pure call to local %tmp_addsub_22 at -44($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: m = %tmp_addsub_22:INTEGER
	# Ensuring operand %tmp_addsub_22:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -44($fp)
	# Loaded local var %tmp_addsub_22 from -44($fp) into $t0
	sw $t0, -120($fp)
	# Stored to local m at -120($fp)
	# Released temporary register $t0
	j .L_while_cond_12
.L_while_end_14:
merge_epilogue:
	# Epilogue for merge
	lw $ra, 4($fp)
	lw $fp, 0($fp)
	addiu $sp, $sp, 128
	jr $ra
	nop
	# Parameter 'start' assigned stack offset: -4($fp)
	# Parameter 'end' assigned stack offset: -8($fp)
	# Local var '%tmp_addsub_24' assigned stack offset: -12($fp)
	# Local var '%tmp_addsub_26' assigned stack offset: -16($fp)
	# Local var '%tmp_muldiv_25' assigned stack offset: -20($fp)
	# Local var '%tmp_rel_23' assigned stack offset: -24($fp)
	# Local var 'mid' assigned stack offset: -28($fp)
	# Function mergeSort: totalLocalVarSize = -28, frameSize = 36
mergeSort:
	# Prologue for mergeSort
	addiu $sp, $sp, -36
	sw $ra, 32($sp)
	sw $fp, 28($sp)
	addiu $fp, $sp, 28
	sw $a0, -4($fp)
	# Stored $a0 (param 'start') to -4($fp)
	sw $a1, -8($fp)
	# Stored $a1 (param 'end') to -8($fp)
	# CallPureInst: CALL_PURE __builtin_ge_int(start:INTEGER, end:INTEGER) -> (%tmp_rel_23:INTEGER)
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	# Ensuring operand end:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var end from -8($fp) into $t1
	# Reserved temporary register $t2
	slt $t2, $t0, $t1
	xori $t2, $t2, 1
	sw $t2, -24($fp)
	# Stored result of pure call to local %tmp_rel_23 at -24($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CondJumpInst: if (%tmp_rel_23:INTEGER) goto .L_if_then_15 else goto .L_if_endif_17
	# Ensuring operand %tmp_rel_23:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -24($fp)
	# Loaded local var %tmp_rel_23 from -24($fp) into $t0
	bnez $t0, .L_if_then_15
	nop
	j .L_if_endif_17
	nop
	# Released temporary register $t0
	# --- End of CondJumpInst ---
.L_if_then_15:
	j mergeSort_epilogue
	nop
.L_if_endif_17:
	# CallPureInst: CALL_PURE __builtin_add_int(start:INTEGER, end:INTEGER) -> (%tmp_addsub_24:INTEGER)
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	# Ensuring operand end:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var end from -8($fp) into $t1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -12($fp)
	# Stored result of pure call to local %tmp_addsub_24 at -12($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# CallPureInst: CALL_PURE __builtin_div_int(%tmp_addsub_24:INTEGER, 2) -> (%tmp_muldiv_25:INTEGER)
	# Ensuring operand %tmp_addsub_24:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -12($fp)
	# Loaded local var %tmp_addsub_24 from -12($fp) into $t0
	# Ensuring operand 2 is in a register
	# Reserved temporary register $t1
	li $t1, 2
	# Reserved temporary register $t2
	div $t0, $t1
	mflo $t2
	sw $t2, -20($fp)
	# Stored result of pure call to local %tmp_muldiv_25 at -20($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# AssignInst: mid = %tmp_muldiv_25:INTEGER
	# Ensuring operand %tmp_muldiv_25:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -20($fp)
	# Loaded local var %tmp_muldiv_25 from -20($fp) into $t0
	sw $t0, -28($fp)
	# Stored to local mid at -28($fp)
	# Released temporary register $t0
	# --- Calling function: mergeSort ---
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	move $a0, $t0
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -28($fp)
	# Loaded local var mid from -28($fp) into $t1
	move $a1, $t1
	jal mergeSort
	nop
	# Released temporary register $t0
	# Released temporary register $t1
	# --- End of call to mergeSort ---
	# CallPureInst: CALL_PURE __builtin_add_int(mid:INTEGER, 1) -> (%tmp_addsub_26:INTEGER)
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -28($fp)
	# Loaded local var mid from -28($fp) into $t0
	# Ensuring operand 1 is in a register
	# Reserved temporary register $t1
	li $t1, 1
	# Reserved temporary register $t2
	addu $t2, $t0, $t1
	sw $t2, -16($fp)
	# Stored result of pure call to local %tmp_addsub_26 at -16($fp)
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# --- Calling function: mergeSort ---
	# Ensuring operand %tmp_addsub_26:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -16($fp)
	# Loaded local var %tmp_addsub_26 from -16($fp) into $t0
	move $a0, $t0
	# Ensuring operand end:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -8($fp)
	# Loaded local var end from -8($fp) into $t1
	move $a1, $t1
	jal mergeSort
	nop
	# Released temporary register $t0
	# Released temporary register $t1
	# --- End of call to mergeSort ---
	# --- Calling function: merge ---
	# Ensuring operand start:INTEGER is in a register
	# Reserved temporary register $t0
	lw $t0, -4($fp)
	# Loaded local var start from -4($fp) into $t0
	move $a0, $t0
	# Ensuring operand mid:INTEGER is in a register
	# Reserved temporary register $t1
	lw $t1, -28($fp)
	# Loaded local var mid from -28($fp) into $t1
	move $a1, $t1
	# Ensuring operand end:INTEGER is in a register
	# Reserved temporary register $t2
	lw $t2, -8($fp)
	# Loaded local var end from -8($fp) into $t2
	move $a2, $t2
	jal merge
	nop
	# Released temporary register $t0
	# Released temporary register $t1
	# Released temporary register $t2
	# --- End of call to merge ---
mergeSort_epilogue:
	# Epilogue for mergeSort
	lw $ra, 4($fp)
	lw $fp, 0($fp)
	addiu $sp, $sp, 36
	jr $ra
	nop

.data
_newline: .asciiz "\n"
# Global Variables
ArrLen: .word 20
arr: .space 80 # Array: 20 elements * 4 bytes each
result: .space 80 # Array: 20 elements * 4 bytes each

# String Literals
_S0: .asciiz "arr[%d] = %d\n"

